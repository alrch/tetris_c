# Tetris CLI (C)

Консольная реализация классической игры Тетрис с использованием конечного
автомата и слоистой архитектуры.

## Цель проекта

* Реализовать игру Тетрис в терминале с чёткой архитектурой
* Применить **Finite State Machine (FSM)** для управления состояниями игры
* Освоить разработку на языке **C** с акцентом на модульность и тестируемость
* Отделить логику игры от ввода/вывода и представления
* Написать unit-тесты с покрытием более 90%
* Практический опыт работы с **ncurses** и управлением терминалом
* Освоить генерацию документации с помощью Doxygen и LaTeX
* Научиться оформлять код в соответствии с требованиями автоматической
документации, включая избыточное для небольшого проекта число комментариев
(частично созданных с использованием ИИ для ускорения)

## Стек

- **C11** — основной язык разработки  
- **ncurses** — управление терминалом и отрисовка интерфейса  
- **Check** — фреймворк для unit-тестирования  
- **Makefile** — сборка, запуск и тестирование проекта  
- **Finite State Machine (FSM)** — управление жизненным циклом игры   
- **Doxygen + LaTeX** — генерация технической документации по кодовой базе

## Быстрый старт

```bash
git clone https://github.com/alrch/tetris_c/
cd tetris_c/src

# Установка зависимостей для Ubuntu/Debian
sudo apt install libncurses5-dev libcheck-dev

# Сборка и запуск
make run

# Только сборка
make build

# Запуск из исходников
./build/tetris
```

Управление:
- **R** — старт 
- **← →** — перемещение фигуры по горизонтали  
- **↑** — поворот фигуры  
- **↓** — ускоренное падение  
- **P** — пауза / возобновление  
- **Q** — выход из игры  

## Возможности

* Полноценная механика Тетриса: падение, вращение, линии, очки
* Поддержка **паузы**
* Автоматическое ускорение падения с ростом уровня
* Чёткое разделение **логики**, **состояния** и **отображения**
* Безопасная работа с таймерами и сигналами (`SIGALRM`)
* Graceful shutdown при завершении игры или ошибке

## Архитектура

Проект следует принципам **слоистой архитектуры** и использует
**конечный автомат** для оркестрации состояний.

### Общая схема

```md
┌───────────────────┐
│    Presentation   │  ncurses, отрисовка, ввод
│   (UI Layer)      │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│     Game Loop     │  FSM: START → SPAWN → MOVE → ...
│   & State Machine │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│    Domain Logic   │  Board, Tetromino, collision,
│   (Core Rules)    │  line clearing, scoring
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│  Infrastructure   │  Timer, signal handling,
│                   │  memory management
└───────────────────┘
```

### Структура проекта

```md
src/
├── brick_game/
│   └── tetris/              # Ядро игровой логики
│       ├── backend.c        # Правила игры, состояние доски, логика фигур
│       ├── fsm.c            # Реализация конечного автомата
│       └── tetris.c         # main() и верхнеуровневый игровой цикл
├── gui/
│   └── cli/
│       └── frontend.c       # UI в терминале через ncurses
├── include/                 # Публичные заголовочные файлы
│   ├── backend.h
│   ├── fsm.h
│   ├── frontend.h
│   ├── defines.h            # Константы, макросы, настройки
│   ├── mock_ncurses.h       # Заглушки для тестирования
│   └── tetris.h             # Главный заголовок (включает все модули)
├── tests/
│   ├── tests.c              # Unit-тесты (фреймворк Check)
│   └── mock_ncurses.c       # Моки функций ncurses
└── Makefile                 # Сборка, тесты, документация, анализ
```

## Слои и ответственность

### Core (Domain)

* Модели: `Board`, `Tetromino`, `GameState`
* Логика:
  - проверка коллизий
  - удаление полных линий
  - расчёт очков и уровня
  - генерация новых фигур
* Полностью **не зависит от ncurses или ввода**

### FSM (Game State Machine)

* Состояния: `START`, `SPAWN`, `MOVE`, `LOCK`, `LINE_CLEAR`, `PAUSE`,
`GAME_OVER`
* Чёткие правила перехода между состояниями
* Изоляция побочных эффектов (например, таймер срабатывает → переход в `MOVE`)
* Упрощает тестирование и расширение (например, добавление меню)

### UI Layer

* Инициализация и закрытие `ncurses`
* Отрисовка доски, следующей фигуры, счёта, уровня
* Обработка пользовательского ввода (клавиши)
* Передача событий в FSM (`KEY_LEFT`, `KEY_PAUSE` и т.д.)

### Utils

* Настройка POSIX-таймера (`timer_create`, `SIGALRM`)
* Безопасное выделение/освобождение памяти
* Обработка сигналов (корректный выход при прерывании)

### Тестирование

* Unit-тесты только для **чистой логики** (core, fsm)
* Фреймворк **Check** — изолированные тестовые случаи
* Нет тестов на UI (ncurses не тестируется напрямую)
* Покрыты критические сценарии:
  - корректное удаление линий
  - блокировка фигуры при столкновении
  - валидность вращения
  - переходы FSM при паузе/возобновлении

Запуск тестов:
```bash
make test
```

> **Примечание**: тесты не используют AI или автогенерацию — все кейсы написаны
вручную для контроля качества.
